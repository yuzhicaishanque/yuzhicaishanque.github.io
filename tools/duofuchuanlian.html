<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>å¤šé‡œä¸²è”å®éªŒæ•°æ®å¤„ç†</title>
    
    <script src="https://cdn.staticfile.org/plotly.js/2.24.1/plotly.min.js"></script>
    <script src="https://cdn.staticfile.org/PapaParse/5.4.1/papaparse.min.js"></script>
    <script src="https://cdn.staticfile.org/xlsx/0.18.5/xlsx.full.min.js"></script>
    
    <style>
        body { font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif; margin: 0; padding: 0; background-color: #f4f6f9; display: flex; height: 100vh; }
        .sidebar { width: 300px; background: white; padding: 20px; border-right: 1px solid #e1e4e8; display: flex; flex-direction: column; overflow-y: auto; box-shadow: 2px 0 10px rgba(0,0,0,0.02); }
        .sidebar h2 { font-size: 1.1rem; border-bottom: 2px solid #ff4b4b; padding-bottom: 8px; margin-bottom: 20px; color: #333; }
        .input-group { margin-bottom: 18px; }
        .input-group label { display: block; font-weight: 600; margin-bottom: 6px; font-size: 0.9rem; color: #555; }
        .input-group input { width: 100%; padding: 8px 12px; border: 1px solid #dfe1e5; border-radius: 4px; box-sizing: border-box; transition: border 0.2s; }
        .input-group input:focus { border-color: #ff4b4b; outline: none; }
        .btn-primary { background: #ff4b4b; color: white; border: none; padding: 12px; border-radius: 6px; cursor: pointer; width: 100%; font-weight: 600; margin-top: 10px; font-size: 1rem; transition: background 0.2s; }
        .btn-primary:hover { background: #e03e3e; }
        .btn-download { background: #0083B8; margin-top: 20px; }
        .btn-download:hover { background: #0072a3; }
        .main { flex: 1; padding: 40px; overflow-y: auto; }
        .card { background: white; padding: 25px; border-radius: 8px; box-shadow: 0 2px 12px rgba(0,0,0,0.05); margin-bottom: 30px; border: 1px solid #f0f0f0; }
        .card h3 { margin-top: 0; color: #333; border-left: 4px solid #ff4b4b; padding-left: 10px; font-size: 1.2rem; }
        #loading { display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(255,255,255,0.95); z-index: 1000; justify-content: center; align-items: center; flex-direction: column; color: #333; }
    </style>
</head>
<body>

<div id="loading">
    <div style="font-size: 3rem; margin-bottom: 10px;">ğŸ§ª</div>
    <div id="loading_text" style="font-size: 1.2rem; font-weight: 500;">æ•°æ®è®¡ç®—ä¸­...</div>
</div>

<div class="sidebar">
    <h2>âš™ï¸ 1. å‚æ•°è®¾ç½®</h2>
    <div class="input-group"><label>æœ‰æ•ˆä½“ç§¯ V (mL)</label><input type="number" id="vol" value="1040.0"></div>
    <div class="input-group"><label>æµé‡ Q (mL/min)</label><input type="number" id="flow" value="225.0"></div>
    <div class="input-group" style="background: #f1f8ff; padding: 12px; border-radius: 6px; border: 1px solid #cce5ff;">
        <label style="color: #004085;">ç†è®ºåœç•™æ—¶é—´ Ï„ (s)</label>
        <div id="theo_tau" style="font-size: 1.4rem; font-weight: bold; color: #0056b3;">277.33</div>
    </div>

    <h2 style="margin-top: 30px;">ğŸ“‚ 2. ä¸Šä¼ æ•°æ®</h2>
    <div class="input-group"><label>600 rpm (å¿…é¡»)</label><input type="file" id="file_600" accept=".csv"></div>
    <div class="input-group"><label>300 rpm (å¯é€‰)</label><input type="file" id="file_300" accept=".csv"></div>
    <div class="input-group"><label>0 rpm (å¯é€‰)</label><input type="file" id="file_0" accept=".csv"></div>

    <button class="btn-primary" onclick="startProcess()">ğŸš€ å¼€å§‹å¤„ç†</button>
    <button class="btn-primary btn-download" id="btn_download" style="display:none;" onclick="downloadExcel()">ğŸ“¥ å¯¼å‡º Excel æŠ¥å‘Š</button>
</div>

<div class="main">
    <div style="margin-bottom: 30px;">
        <h1 style="margin: 0; color: #1a1a1a;">âš—ï¸ å¤šé‡œä¸²è”æ•°æ®å¤„ç†</h1>
        <p style="color: #666; margin-top: 8px;">è¾“å…¥æ•°æ®å¹¶è¿›è¡Œå¤„ç†ã€‚</p>
    </div>

    <div class="card">
        <h3>ğŸ“Š 1å·é‡œä¸åŒè½¬é€Ÿ E(t) å¯¹æ¯”</h3>
        <div id="chart_compare" style="height: 500px;"></div>
    </div>

    <div class="card" id="detail_container" style="display:none;">
        <h3>ğŸ“ˆ 600 rpm å„é‡œæ¨¡å‹æ‹Ÿåˆè¯¦æƒ…</h3>
        <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 25px;">
            <div id="chart_detail_1" style="height: 380px;"></div>
            <div id="chart_detail_2" style="height: 380px;"></div>
            <div id="chart_detail_3" style="height: 380px;"></div>
            <div id="chart_detail_4" style="height: 380px;"></div>
        </div>
    </div>
</div>

<script>
    // --- æ•°å­¦å·¥å…· ---
    function trapz(y, x) {
        let sum = 0;
        for (let i = 0; i < x.length - 1; i++) {
            sum += 0.5 * (y[i+1] + y[i]) * (x[i+1] - x[i]);
        }
        return sum;
    }

    function gamma(z) {
        if (z < 0.5) return Math.PI / (Math.sin(Math.PI * z) * gamma(1 - z));
        z -= 1;
        let x = 0.99999999999980993;
        let p = [676.5203681218851, -1259.1392167224028, 771.32342877765313, -176.61502916214059, 12.507343278686905, -0.13857109526572012, 9.9843695780195716e-6, 1.5056327351493116e-7];
        for (let i = 0; i < p.length; i++) x += p[i] / (z + i + 1);
        let t = z + p.length - 0.5;
        return Math.sqrt(2 * Math.PI) * Math.pow(t, z + 0.5) * Math.exp(-t) * x;
    }

    function getTheoreticalE(tArr, tau, N) {
        if (N < 1) N = 1;
        if (tau === 0) return tArr.map(() => 0);
        const coeff = (Math.pow(N, N)) / (Math.pow(tau, N) * gamma(N));
        return tArr.map(t => {
            if (t < 0) return 0;
            return coeff * Math.pow(t, N - 1) * Math.exp(-N * t / tau);
        });
    }

    let globalResults = {}; 

    document.querySelectorAll('#vol, #flow').forEach(el => {
        el.addEventListener('input', () => {
            const V = parseFloat(document.getElementById('vol').value);
            const Q = parseFloat(document.getElementById('flow').value);
            const tau = Q === 0 ? 0 : (V / Q) * 60;
            document.getElementById('theo_tau').innerText = tau.toFixed(2);
        });
    });

    async function startProcess() {
        const file600 = document.getElementById('file_600').files[0];
        const file300 = document.getElementById('file_300').files[0];
        const file0 = document.getElementById('file_0').files[0];

        if (!file600) { alert("âŒ è¯·è‡³å°‘ä¸Šä¼  600 rpm çš„æ•°æ®æ–‡ä»¶ï¼"); return; }
        
        document.getElementById('loading').style.display = 'flex';
        globalResults = {}; 

        const V = parseFloat(document.getElementById('vol').value);
        const Q = parseFloat(document.getElementById('flow').value);
        const theoTau = (V / Q) * 60;

        try {
            const tasks = [
                { file: file600, keyword: '1å·', colIndex: 1, theoN: 1, rpm: '600', name: '1å·é‡œ' },
                { file: file600, keyword: '2å·', colIndex: 2, theoN: 2, rpm: '600', name: '2å·é‡œ' },
                { file: file600, keyword: '3å·', colIndex: 3, theoN: 3, rpm: '600', name: '3å·é‡œ' },
                { file: file600, keyword: '4å·', colIndex: 4, theoN: 4, rpm: '600', name: '4å·é‡œ' },
                { file: file300, keyword: '1å·', colIndex: 1, theoN: 1, rpm: '300', name: '1å·é‡œ' },
                { file: file0,   keyword: '1å·', colIndex: 1, theoN: 1, rpm: '0',   name: '1å·é‡œ' }
            ];

            const compareTraces = [];
            
            for (let task of tasks) {
                if (!task.file) continue;
                
                const text = await readFileAsText(task.file);
                const parseResult = Papa.parse(text, { header: true, dynamicTyping: true, skipEmptyLines: true, encoding: "GBK" });
                
                let data = parseResult.data;
                let meta = parseResult.meta;
                let fields = meta.fields;

                let targetKey = fields.find(f => f.includes(task.keyword));
                if (!targetKey) {
                    if (fields.length > task.colIndex) targetKey = fields[task.colIndex];
                    else continue;
                }

                const timeKey = fields[0];
                let rawT = [], rawC = [], rawTimeStr = [];
                
                let startTime = 0;
                if (data.length > 0 && data[0][timeKey]) startTime = tryParseTime(data[0][timeKey]);

                data.forEach(row => {
                    let val = row[targetKey];
                    let tRaw = row[timeKey];
                    if (val !== undefined && tRaw !== undefined) {
                        let t_sec = tryParseTime(tRaw) - startTime;
                        if (isNaN(t_sec)) t_sec = parseFloat(tRaw);
                        if (t_sec < 0) t_sec = parseFloat(tRaw);
                        rawT.push(t_sec);
                        rawC.push(parseFloat(val));
                        rawTimeStr.push(tRaw); 
                    }
                });

                if (rawT.length === 0) continue;

                const baseline = rawC[0];
                const netC = rawC.map(c => Math.max(c - baseline, 0));
                
                const area = trapz(netC, rawT);
                if (area === 0) continue; 

                const moment1 = trapz(rawT.map((t, i) => t * netC[i]), rawT);
                const tMean = moment1 / area;
                const moment2 = trapz(rawT.map((t, i) => t*t * netC[i]), rawT);
                const variance = (moment2 / area) - tMean*tMean;
                const N_model = variance !== 0 ? (tMean*tMean) / variance : 0;
                const E_t = netC.map(c => c / area);

                const key = `${task.name} (${task.rpm} rpm)`;
                globalResults[key] = {
                    t: rawT, E: E_t, rawC: rawC, netC: netC, rawTimeStr: rawTimeStr,
                    stats: { tMean, variance, N_model, area, moment1, moment2 },
                    theoN: task.theoN
                };

                if (task.name === '1å·é‡œ') {
                    compareTraces.push({
                        x: rawT, y: E_t, mode: 'lines', name: `${task.rpm} rpm`, // ç®€åŒ–å›¾ä¾‹æ–‡å­—ï¼Œé˜²æ­¢è¿‡é•¿
                        line: { width: 2 }
                    });
                }
            }

            if (compareTraces.length === 0) {
                alert("âŒ æœªæå–åˆ°æœ‰æ•ˆæ•°æ®ï¼Œè¯·æ£€æŸ¥CSVæ ¼å¼ã€‚");
                return;
            }

            const maxT = Math.max(...compareTraces[0].x);
            const tRef = Array.from({length: 500}, (_, i) => i * maxT / 499);
            const ERef = getTheoreticalE(tRef, theoTau, 1);
            
            compareTraces.push({
                x: tRef, y: ERef, mode: 'lines', name: 'ç†è®ºå…¨æ··æµ',
                line: { color: 'black', dash: 'dash', width: 1.5 }
            });

            // ---------------------------------------------------------
            // ğŸ¨ 1. å®šä¹‰æ ¸å¿ƒæ ·å¼
            // ---------------------------------------------------------
            
            // æ‚¬æµ®å›¾ä¾‹æ ·å¼ (ä½ çš„æ ¸å¿ƒéœ€æ±‚)
            const legendStyle = {
                x: 0.99, y: 0.98, // åæ ‡ (0-1)ï¼Œå³ä¸Šè§’
                xanchor: 'right', yanchor: 'top',
                bgcolor: 'rgba(255, 255, 255, 0.85)', // åŠé€æ˜ç™½åº•
                bordercolor: '#ccc', // ç°è‰²è¾¹æ¡†
                borderwidth: 1
            };

            const layoutBase = {
                font: { family: "Microsoft YaHei, -apple-system, sans-serif", size: 12, color: "#333" },
                xaxis: { 
                    title: { text: 'æ—¶é—´ t (s)', standoff: 15 },
                    range: [0, null], rangemode: 'nonnegative', 
                    zeroline: true, zerolinecolor: '#333', zerolinewidth: 2,
                    showgrid: true, gridcolor: '#e0e0e0', gridwidth: 1, griddash: 'dot' 
                },
                yaxis: { 
                    title: { text: 'E(t)', standoff: 15 },
                    range: [0, null], rangemode: 'nonnegative', 
                    zeroline: true, zerolinecolor: '#333', zerolinewidth: 2,
                    showgrid: true, gridcolor: '#e0e0e0', gridwidth: 1, griddash: 'dot'
                },
                paper_bgcolor: 'white',
                plot_bgcolor: 'white',
                hovermode: 'x unified',
                legend: legendStyle, // âœ¨ è¿™é‡Œåº”ç”¨å…¨å±€å›¾ä¾‹æ ·å¼
                margin: { t: 60, r: 20, b: 70, l: 80 }
            };

            const configDl = {
                toImageButtonOptions: { format: 'png', filename: 'å®éªŒå›¾è¡¨', height: 900, width: 1200, scale: 2 },
                displayModeBar: true, displaylogo: false
            };

            // ç»˜åˆ¶å›¾1
            Plotly.newPlot('chart_compare', compareTraces, {...layoutBase, title: '1å·é‡œä¸åŒè½¬é€Ÿ E(t) å¯¹æ¯”'}, configDl);

            document.getElementById('detail_container').style.display = 'block';
            const detailKeys = ['1å·é‡œ (600 rpm)', '2å·é‡œ (600 rpm)', '3å·é‡œ (600 rpm)', '4å·é‡œ (600 rpm)'];
            
            // ç»˜åˆ¶è¯¦ç»†å›¾
            detailKeys.forEach((k, idx) => {
                const domId = `chart_detail_${idx+1}`;
                if (globalResults[k]) {
                    const res = globalResults[k];
                    const ETheo = getTheoreticalE(tRef, res.stats.tMean, res.theoN);
                    
                    const traces = [
                        { x: res.t, y: res.E, mode: 'lines', name: 'å®æµ‹å€¼ (Exp)', line: {color: '#ff7f0e', width: 2.5} },
                        { x: tRef, y: ETheo, mode: 'lines', name: `ç†è®ºå€¼ (N=${res.theoN})`, line: {color: 'black', dash: 'dash', width: 2} }
                    ];

                    Plotly.newPlot(domId, traces, 
                        {...layoutBase, title: `${k} (N=${res.stats.N_model.toFixed(2)})`}, 
                        {...configDl, toImageButtonOptions: {...configDl.toImageButtonOptions, filename: k}}
                    );
                } else {
                    document.getElementById(domId).innerHTML = `<div style='text-align:center;line-height:350px;color:#ccc;'>æ—  ${k} æ•°æ®</div>`;
                }
            });

            document.getElementById('btn_download').style.display = 'block';

        } catch (err) {
            console.error(err);
            alert("å¤„ç†å‡ºé”™: " + err.message);
        } finally {
            document.getElementById('loading').style.display = 'none';
        }
    }

    function tryParseTime(input) {
        if (typeof input === 'number') return input;
        const t = new Date(input).getTime();
        if (!isNaN(t)) return t / 1000;
        return parseFloat(input);
    }

    function readFileAsText(file) {
        return new Promise((resolve, reject) => {
            const reader = new FileReader();
            reader.onload = (e) => resolve(e.target.result);
            reader.onerror = (e) => reject(e);
            reader.readAsText(file, 'GBK'); 
        });
    }

    function downloadExcel() {
        if (typeof XLSX === 'undefined') { alert("XLSX åº“æœªåŠ è½½"); return; }
        const wb = XLSX.utils.book_new();

        for (let [sheetName, res] of Object.entries(globalResults)) {
            const L = res.netC; const t = res.t; const rawTime = res.rawTimeStr; const rawC = res.rawC;
            const targetCount = 25; const totalLen = t.length; const step = Math.max(1, Math.floor(totalLen / targetCount));
            const sheetData = [['åŸå§‹æ—¶é—´', 'åŸå§‹ç”µå¯¼ç‡', 't (s)', 'L(t) (å‡€å€¼)', 't*L(t)', 't^2*L(t)', '', 'ç»Ÿè®¡é¡¹', 'è®¡ç®—ç»“æœ']];

            for (let i = 0; i < totalLen; i += step) {
                if (i >= totalLen) break;
                const val_L = L[i]; const val_t = t[i];
                let row = [rawTime[i], rawC[i], val_t, val_L, val_t * val_L, val_t * val_t * val_L, '', '', ''];
                sheetData.push(row);
            }
            const setStat = (rowIdx, name, val) => { if (sheetData[rowIdx]) { sheetData[rowIdx][7] = name; sheetData[rowIdx][8] = val; } };
            setStat(1, 'L(t)ä¹‹å’Œ (ç§¯åˆ†é¢ç§¯)', res.stats.area);
            setStat(2, 't*L(t)ä¹‹å’Œ (ä¸€é˜¶çŸ©)', res.stats.moment1);
            setStat(3, 't^2*L(t)ä¹‹å’Œ (äºŒé˜¶çŸ©)', res.stats.moment2);
            setStat(4, 'å¹³å‡åœç•™æ—¶é—´ (s)', res.stats.tMean);
            setStat(5, 'æ–¹å·®', res.stats.variance);
            setStat(6, 'æ¨¡æ‹Ÿé‡œæ•° N', res.stats.N_model);
            
            const safeName = sheetName.replace(/[^\u4e00-\u9fa5a-zA-Z0-9]/g, '_').substring(0, 30);
            const ws = XLSX.utils.aoa_to_sheet(sheetData);
            ws['!cols'] = [{wch: 15}, {wch: 12}, {wch: 10}, {wch: 12}, {wch: 15}, {wch: 15}, {wch: 5}, {wch: 25}, {wch: 15}];
            XLSX.utils.book_append_sheet(wb, ws, safeName);
        }
        XLSX.writeFile(wb, "å¤šé‡œä¸²è”å®éªŒæŠ¥å‘Šæ•°æ®.xlsx");
    }
</script>

</body>
</html>