<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>å¤šé‡œä¸²è”å®éªŒæ•°æ®å¤„ç† (å®Œç¾æŠ¥å‘Šç‰ˆ)</title>
    
    <script src="https://cdn.staticfile.org/plotly.js/2.24.1/plotly.min.js"></script>
    <script src="https://cdn.staticfile.org/PapaParse/5.4.1/papaparse.min.js"></script>
    <script src="https://cdn.staticfile.org/xlsx/0.18.5/xlsx.full.min.js"></script>
    
    <style>
        body { font-family: system-ui, -apple-system, sans-serif; margin: 0; padding: 0; background-color: #f0f2f6; display: flex; height: 100vh; }
        .sidebar { width: 300px; background: white; padding: 20px; border-right: 1px solid #ddd; display: flex; flex-direction: column; overflow-y: auto; }
        .sidebar h2 { font-size: 1.1rem; border-bottom: 2px solid #ff4b4b; padding-bottom: 5px; margin-bottom: 15px; }
        .input-group { margin-bottom: 15px; }
        .input-group label { display: block; font-weight: 600; margin-bottom: 5px; font-size: 0.9rem; }
        .input-group input { width: 100%; padding: 8px; border: 1px solid #ccc; border-radius: 4px; box-sizing: border-box; }
        .btn-primary { background: #ff4b4b; color: white; border: none; padding: 10px; border-radius: 5px; cursor: pointer; width: 100%; font-weight: bold; margin-top: 10px; }
        .btn-primary:hover { background: #d93e3e; }
        .btn-download { background: #0083B8; margin-top: 20px; display: none; }
        .main { flex: 1; padding: 30px; overflow-y: auto; }
        .card { background: white; padding: 20px; border-radius: 8px; box-shadow: 0 1px 3px rgba(0,0,0,0.1); margin-bottom: 20px; }
        #loading { display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(255,255,255,0.9); z-index: 1000; justify-content: center; align-items: center; flex-direction: column; color: #ff4b4b; font-weight: bold; }
    </style>
</head>
<body>

<div id="loading">
    <div style="font-size: 2rem;">ğŸš€</div>
    <div id="loading_text">æ­£åœ¨è®¡ç®—ä¸­...</div>
</div>

<div class="sidebar">
    <h2>âš™ï¸ 1. å‚æ•°è®¾ç½®</h2>
    <div class="input-group"><label>æœ‰æ•ˆä½“ç§¯ V (mL)</label><input type="number" id="vol" value="1040.0"></div>
    <div class="input-group"><label>æµé‡ Q (mL/min)</label><input type="number" id="flow" value="225.0"></div>
    <div class="input-group" style="background: #e8f0fe; padding: 10px; border-radius: 5px;">
        <label>ç†è®ºåœç•™æ—¶é—´ Ï„ (s)</label>
        <div id="theo_tau" style="font-size: 1.2rem; font-weight: bold; color: #0068c9;">277.33</div>
    </div>

    <h2>ğŸ“‚ 2. ä¸Šä¼  CSV æ•°æ®</h2>
    <div class="input-group"><label>600 rpm (å¿…é¡»)</label><input type="file" id="file_600" accept=".csv"></div>
    <div class="input-group"><label>300 rpm (å¯é€‰)</label><input type="file" id="file_300" accept=".csv"></div>
    <div class="input-group"><label>0 rpm (å¯é€‰)</label><input type="file" id="file_0" accept=".csv"></div>

    <button class="btn-primary" onclick="startProcess()">ğŸš€ å¼€å§‹å¤„ç†</button>
    <button class="btn-primary btn-download" id="btn_download" onclick="downloadExcel()">ğŸ“¥ ä¸‹è½½ Excel æŠ¥å‘Š</button>
</div>

<div class="main">
    <div style="margin-bottom: 20px;">
        <h1 style="margin: 0;">âš—ï¸ å¤šé‡œä¸²è”æ•°æ®å¤„ç† (æŠ¥å‘Šä¸“ç”¨ç‰ˆ)</h1>
        <p style="color: #666;">è‡ªåŠ¨æŠ½æ · 25 ç»„æ•°æ®ï¼ŒåŒ…å« L(t) ç§¯åˆ†è¡¨ä¸å®Œæ•´ç»Ÿè®¡æŒ‡æ ‡ã€‚</p>
    </div>

    <div class="card">
        <h3>ğŸ“Š 1å·é‡œä¸åŒè½¬é€Ÿ E(t) å¯¹æ¯”</h3>
        <div id="chart_compare" style="height: 500px;"></div>
    </div>

    <div class="card" id="detail_container" style="display:none;">
        <h3>ğŸ“ˆ 600 rpm å„é‡œæ¨¡å‹æ‹Ÿåˆè¯¦æƒ…</h3>
        <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 20px;">
            <div id="chart_detail_1" style="height: 350px;"></div>
            <div id="chart_detail_2" style="height: 350px;"></div>
            <div id="chart_detail_3" style="height: 350px;"></div>
            <div id="chart_detail_4" style="height: 350px;"></div>
        </div>
    </div>
</div>

<script>
    // --- æ•°å­¦å·¥å…· ---
    function trapz(y, x) {
        let sum = 0;
        for (let i = 0; i < x.length - 1; i++) {
            sum += 0.5 * (y[i+1] + y[i]) * (x[i+1] - x[i]);
        }
        return sum;
    }

    function gamma(z) {
        if (z < 0.5) return Math.PI / (Math.sin(Math.PI * z) * gamma(1 - z));
        z -= 1;
        let x = 0.99999999999980993;
        let p = [676.5203681218851, -1259.1392167224028, 771.32342877765313, -176.61502916214059, 12.507343278686905, -0.13857109526572012, 9.9843695780195716e-6, 1.5056327351493116e-7];
        for (let i = 0; i < p.length; i++) x += p[i] / (z + i + 1);
        let t = z + p.length - 0.5;
        return Math.sqrt(2 * Math.PI) * Math.pow(t, z + 0.5) * Math.exp(-t) * x;
    }

    function getTheoreticalE(tArr, tau, N) {
        if (N < 1) N = 1;
        if (tau === 0) return tArr.map(() => 0);
        const coeff = (Math.pow(N, N)) / (Math.pow(tau, N) * gamma(N));
        return tArr.map(t => {
            if (t < 0) return 0;
            return coeff * Math.pow(t, N - 1) * Math.exp(-N * t / tau);
        });
    }

    // --- å…¨å±€å˜é‡ ---
    let globalResults = {}; 

    // å‚æ•°è”åŠ¨
    document.querySelectorAll('#vol, #flow').forEach(el => {
        el.addEventListener('input', () => {
            const V = parseFloat(document.getElementById('vol').value);
            const Q = parseFloat(document.getElementById('flow').value);
            const tau = Q === 0 ? 0 : (V / Q) * 60;
            document.getElementById('theo_tau').innerText = tau.toFixed(2);
        });
    });

    async function startProcess() {
        const file600 = document.getElementById('file_600').files[0];
        const file300 = document.getElementById('file_300').files[0];
        const file0 = document.getElementById('file_0').files[0];

        if (!file600) { alert("âŒ è¯·è‡³å°‘ä¸Šä¼  600 rpm çš„æ•°æ®æ–‡ä»¶ï¼"); return; }
        
        document.getElementById('loading').style.display = 'flex';
        globalResults = {}; 

        const V = parseFloat(document.getElementById('vol').value);
        const Q = parseFloat(document.getElementById('flow').value);
        const theoTau = (V / Q) * 60;

        try {
            const tasks = [
                { file: file600, keyword: '1å·', colIndex: 1, theoN: 1, rpm: '600', name: '1å·é‡œ' },
                { file: file600, keyword: '2å·', colIndex: 2, theoN: 2, rpm: '600', name: '2å·é‡œ' },
                { file: file600, keyword: '3å·', colIndex: 3, theoN: 3, rpm: '600', name: '3å·é‡œ' },
                { file: file600, keyword: '4å·', colIndex: 4, theoN: 4, rpm: '600', name: '4å·é‡œ' },
                { file: file300, keyword: '1å·', colIndex: 1, theoN: 1, rpm: '300', name: '1å·é‡œ' },
                { file: file0,   keyword: '1å·', colIndex: 1, theoN: 1, rpm: '0',   name: '1å·é‡œ' }
            ];

            const compareTraces = [];
            
            for (let task of tasks) {
                if (!task.file) continue;
                
                const text = await readFileAsText(task.file);
                const parseResult = Papa.parse(text, { 
                    header: true, dynamicTyping: true, skipEmptyLines: true, encoding: "GBK"
                });
                
                let data = parseResult.data;
                let meta = parseResult.meta;
                let fields = meta.fields;

                let targetKey = fields.find(f => f.includes(task.keyword));
                if (!targetKey) {
                    if (fields.length > task.colIndex) {
                        targetKey = fields[task.colIndex];
                    } else {
                        continue;
                    }
                }

                const timeKey = fields[0];
                let rawT = [], rawC = [], rawTimeStr = []; // æ–°å¢ï¼šrawTimeStr
                
                let startTime = 0;
                if (data.length > 0 && data[0][timeKey]) {
                    startTime = tryParseTime(data[0][timeKey]);
                }

                data.forEach(row => {
                    let val = row[targetKey];
                    let tRaw = row[timeKey];
                    
                    if (val !== undefined && tRaw !== undefined) {
                        let t_sec = tryParseTime(tRaw) - startTime;
                        if (isNaN(t_sec)) t_sec = parseFloat(tRaw);
                        if (t_sec < 0) t_sec = parseFloat(tRaw);

                        rawT.push(t_sec);
                        rawC.push(parseFloat(val));
                        // ä¿å­˜åŸå§‹æ—¶é—´å­—ç¬¦ä¸²ï¼Œå¦‚æœæ˜¯æ—¥æœŸå¯¹è±¡åˆ™è½¬å­—ç¬¦ä¸²
                        rawTimeStr.push(tRaw); 
                    }
                });

                if (rawT.length === 0) continue;

                const baseline = rawC[0];
                const netC = rawC.map(c => Math.max(c - baseline, 0));
                
                const area = trapz(netC, rawT);
                if (area === 0) continue; 

                // çŸ©è®¡ç®—
                const moment1 = trapz(rawT.map((t, i) => t * netC[i]), rawT);
                const tMean = moment1 / area;
                const moment2 = trapz(rawT.map((t, i) => t*t * netC[i]), rawT);
                const variance = (moment2 / area) - tMean*tMean;
                const N_model = variance !== 0 ? (tMean*tMean) / variance : 0;
                const E_t = netC.map(c => c / area);

                const key = `${task.name} (${task.rpm} rpm)`;
                globalResults[key] = {
                    t: rawT, E: E_t, rawC: rawC, netC: netC, rawTimeStr: rawTimeStr,
                    stats: { tMean, variance, N_model, area, moment1, moment2 },
                    theoN: task.theoN
                };

                if (task.name === '1å·é‡œ') {
                    compareTraces.push({
                        x: rawT, y: E_t, mode: 'lines', name: `${task.rpm} rpm å®æµ‹`,
                        line: { width: 2 }
                    });
                }
            }

            if (compareTraces.length === 0) {
                alert("âŒ æœªæå–åˆ°æœ‰æ•ˆæ•°æ®ï¼Œè¯·æ£€æŸ¥CSVæ ¼å¼ã€‚");
                return;
            }

            // ç»˜å›¾
            const maxT = Math.max(...compareTraces[0].x);
            const tRef = Array.from({length: 500}, (_, i) => i * maxT / 499);
            const ERef = getTheoreticalE(tRef, theoTau, 1);
            
            compareTraces.push({
                x: tRef, y: ERef, mode: 'lines', name: 'ç†è®ºå…¨æ··æµ (N=1)',
                line: { color: 'black', dash: 'dash', width: 1.5 }
            });

            // ä¿®å¤æ ·å¼ï¼šåŸç‚¹å¯¹é½ï¼Œæ ‡é¢˜ä¸é‡å 
            const layoutCommon = {
                font: { family: "Microsoft YaHei, sans-serif" },
                xaxis: { 
                    title: { text: 'æ—¶é—´ t (s)', standoff: 20 },
                    range: [0, null], rangemode: 'nonnegative', zeroline: true 
                },
                yaxis: { 
                    title: { text: 'E(t)', standoff: 20 },
                    range: [0, null], rangemode: 'nonnegative', zeroline: true 
                },
                hovermode: 'x unified',
                template: 'simple_white',
                margin: { t: 50, r: 30, b: 80, l: 80 }
            };

            const configDl = {
                toImageButtonOptions: { format: 'png', filename: 'è½¬é€Ÿå¯¹æ¯”', height: 600, width: 800, scale: 3 },
                displayModeBar: true, displaylogo: false
            };

            Plotly.newPlot('chart_compare', compareTraces, {...layoutCommon, title: '1å·é‡œä¸åŒè½¬é€Ÿ E(t) å¯¹æ¯”'}, configDl);

            document.getElementById('detail_container').style.display = 'block';
            const detailKeys = ['1å·é‡œ (600 rpm)', '2å·é‡œ (600 rpm)', '3å·é‡œ (600 rpm)', '4å·é‡œ (600 rpm)'];
            
            detailKeys.forEach((k, idx) => {
                const domId = `chart_detail_${idx+1}`;
                if (globalResults[k]) {
                    const res = globalResults[k];
                    const ETheo = getTheoreticalE(tRef, res.stats.tMean, res.theoN);
                    const traces = [
                        { x: res.t, y: res.E, mode: 'lines', name: 'å®æµ‹', line: {width: 2} },
                        { x: tRef, y: ETheo, mode: 'lines', name: `ç†è®ºN=${res.theoN}`, line: {color:'black', dash:'dash'} }
                    ];
                    Plotly.newPlot(domId, traces, 
                        {...layoutCommon, title: `${k} (N=${res.stats.N_model.toFixed(2)})`, height: 350}, 
                        {...configDl, toImageButtonOptions: {...configDl.toImageButtonOptions, filename: k}}
                    );
                } else {
                    document.getElementById(domId).innerHTML = `<div style='text-align:center;line-height:350px;color:#ccc;'>æ—  ${k} æ•°æ®</div>`;
                }
            });

            document.getElementById('btn_download').style.display = 'block';

        } catch (err) {
            console.error(err);
            alert("å¤„ç†å‡ºé”™: " + err.message);
        } finally {
            document.getElementById('loading').style.display = 'none';
        }
    }

    // è¾…åŠ©å‡½æ•°
    function tryParseTime(input) {
        if (typeof input === 'number') return input;
        const t = new Date(input).getTime();
        if (!isNaN(t)) return t / 1000;
        return parseFloat(input);
    }

    function readFileAsText(file) {
        return new Promise((resolve, reject) => {
            const reader = new FileReader();
            reader.onload = (e) => resolve(e.target.result);
            reader.onerror = (e) => reject(e);
            reader.readAsText(file, 'GBK'); 
        });
    }

    // âœ… æ ¸å¿ƒä¿®æ”¹ï¼šExcel å¯¼å‡ºé€»è¾‘
    function downloadExcel() {
        if (typeof XLSX === 'undefined') { alert("XLSX åº“æœªåŠ è½½"); return; }
        const wb = XLSX.utils.book_new();

        for (let [sheetName, res] of Object.entries(globalResults)) {
            // L(t) åœ¨æ­¤è¯­å¢ƒä¸‹å³ Net Concentration (å‡€ç”µå¯¼ç‡)
            const L = res.netC; 
            const t = res.t;
            const rawTime = res.rawTimeStr;
            const rawC = res.rawC;

            // æŠ½æ ·é€»è¾‘ï¼šåªå–çº¦ 25 ä¸ªç‚¹
            const targetCount = 25;
            const totalLen = t.length;
            const step = Math.max(1, Math.floor(totalLen / targetCount));
            
            // è¡¨å¤´
            const sheetData = [
                ['åŸå§‹æ—¶é—´', 'åŸå§‹ç”µå¯¼ç‡', 't (s)', 'L(t) (å‡€å€¼)', 't*L(t)', 't^2*L(t)', '', 'ç»Ÿè®¡é¡¹', 'è®¡ç®—ç»“æœ']
            ];

            // å¡«å……æŠ½æ ·æ•°æ®
            let sampleRowIndex = 1; // æ•°æ®å†™å…¥Excelçš„è¡Œç´¢å¼•
            for (let i = 0; i < totalLen; i += step) {
                // é˜²æ­¢è¶Šç•Œ
                if (i >= totalLen) break;

                const val_L = L[i];
                const val_t = t[i];
                const val_tL = val_t * val_L;
                const val_t2L = val_t * val_t * val_L;

                // æ¯ä¸€è¡Œæ•°æ®
                let row = [
                    rawTime[i],  // åŸå§‹æ—¶é—´
                    rawC[i],     // åŸå§‹ç”µå¯¼ç‡
                    val_t,       // t
                    val_L,       // L(t)
                    val_tL,      // t*L(t)
                    val_t2L,     // t^2*L(t)
                    '',          // ç©ºåˆ—ï¼Œç”¨äºåˆ†éš”
                    '',          // ç»Ÿè®¡é¡¹å (åé¢å¡«å……)
                    ''           // ç»Ÿè®¡æ•°å€¼ (åé¢å¡«å……)
                ];
                
                sheetData.push(row);
                sampleRowIndex++;
            }

            // ç¡®ä¿æœ€åä¸€è¡Œæ•°æ®ä¹ŸåŒ…å«è¿›å»ï¼ˆå¦‚æœæ˜¯é‡ç‚¹ï¼‰
            // è¿™é‡Œä¸ºäº†ä¿æŒ 25 è¡Œå·¦å³ï¼Œå°±ä¸å¼ºè¡ŒåŠ æœ€åä¸€è¡Œäº†ï¼Œå‡åŒ€æŠ½æ ·å³å¯

            // å¡«å……å³ä¾§ç»Ÿè®¡æ•°æ® (åŸºäºå…¨é‡æ•°æ®è®¡ç®—ï¼Œæ›´å‡†ç¡®)
            // L(t)ä¹‹å’Œ -> é¢ç§¯ (Area)
            // t*L(t)ä¹‹å’Œ -> Moment 1
            // t^2*L(t)ä¹‹å’Œ -> Moment 2
            
            // å®‰å…¨å¡«å……å‡½æ•°
            const setStat = (rowIdx, name, val) => {
                if (sheetData[rowIdx]) {
                    sheetData[rowIdx][7] = name;
                    sheetData[rowIdx][8] = val; // ä¿ç•™2ä½å°æ•°åœ¨Excelæ˜¾ç¤ºæ—¶ç”±ç”¨æˆ·æ§åˆ¶ï¼Œæˆ–è€…è¿™é‡ŒtoFixed
                }
            };

            setStat(1, 'L(t)ä¹‹å’Œ (ç§¯åˆ†é¢ç§¯)', res.stats.area); // å¯¹åº”ç§¯åˆ†é¢ç§¯
            setStat(2, 't*L(t)ä¹‹å’Œ (ä¸€é˜¶çŸ©)', res.stats.moment1);
            setStat(3, 't^2*L(t)ä¹‹å’Œ (äºŒé˜¶çŸ©)', res.stats.moment2);
            setStat(4, 'å¹³å‡åœç•™æ—¶é—´ (s)', res.stats.tMean);
            setStat(5, 'æ–¹å·®', res.stats.variance);
            setStat(6, 'æ¨¡æ‹Ÿé‡œæ•° N', res.stats.N_model);
            
            // æ·»åŠ ä¸€ä¸ªè¯´æ˜
            if (sheetData[8]) {
                sheetData[8][7] = 'è¯´æ˜:';
                sheetData[8][8] = 'ç»Ÿè®¡å€¼åŸºäºå…¨éƒ¨æ•°æ®è®¡ç®—';
            }

            const safeName = sheetName.replace(/[^\u4e00-\u9fa5a-zA-Z0-9]/g, '_').substring(0, 30);
            const ws = XLSX.utils.aoa_to_sheet(sheetData);
            
            // è®¾ç½®åˆ—å®½ç¨å¾®å¥½çœ‹ç‚¹
            ws['!cols'] = [
                {wch: 15}, {wch: 12}, {wch: 10}, {wch: 12}, {wch: 15}, {wch: 15}, 
                {wch: 5}, {wch: 25}, {wch: 15}
            ];

            XLSX.utils.book_append_sheet(wb, ws, safeName);
        }
        XLSX.writeFile(wb, "å¤šé‡œä¸²è”å®éªŒæŠ¥å‘Šæ•°æ®.xlsx");
    }
</script>

</body>
</html>