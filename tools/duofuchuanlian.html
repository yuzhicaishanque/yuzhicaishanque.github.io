<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no" />
    <title>åŒ–å·¥åŸç†å®éªŒæ•°æ®å¤„ç†å·¥å…· (Plotlyæé€Ÿç‰ˆ)</title>
    <link rel="stylesheet" href="https://registry.npmmirror.com/@stlite/mountable/0.50.0/files/build/stlite.css" />
    <style>
      #loader { position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); text-align: center; z-index: 9999; font-family: sans-serif; }
      .spinner { border: 6px solid #f3f3f3; border-top: 6px solid #00aeef; border-radius: 50%; width: 50px; height: 50px; animation: spin 1s linear infinite; margin: 0 auto 15px auto; }
      @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
      .loading-text { color: #333; font-weight: bold; }
      .loading-sub { color: #888; font-size: 12px; margin-top: 5px; }
    </style>
  </head>
  <body>
    <div id="root" style="height: 100vh;"></div>

    <div id="loader">
      <div class="spinner"></div>
      <div class="loading-text">ğŸš€ æ­£åœ¨åŠ è½½ Plotly å¼•æ“...</div>
      <div class="loading-sub">æ— éœ€ä¸‹è½½å­—ä½“ï¼Œä½“ç§¯æ›´å°</div>
    </div>

    <script src="https://registry.npmmirror.com/@stlite/mountable/0.50.0/files/build/stlite.js"></script>

    <script>
      stlite.mount({
        // âœ… æ ¸å¿ƒä¿®æ”¹ï¼šå»æ‰ matplotlibï¼ŒåŠ å…¥ plotly
        requirements: ["streamlit", "pandas", "numpy", "plotly", "xlsxwriter"],
        entrypoint: "streamlit_app.py",
        files: {
          "streamlit_app.py": `
import streamlit as st
import pandas as pd
import numpy as np
import plotly.graph_objects as go # âœ… å¼•å…¥ Plotly
import plotly.express as px
import math
import io
import warnings

# --- å…¼å®¹æ€§è®¾ç½® ---
if hasattr(np, 'trapezoid'):
    trapezoid = np.trapezoid
else:
    trapezoid = np.trapz

warnings.filterwarnings('ignore')

# --- é¡µé¢é…ç½® ---
st.set_page_config(page_title="å¤šé‡œä¸²è”å¤„ç†", layout="wide", page_icon="âš—ï¸")

# --- æ ¸å¿ƒç®—æ³• ---
def get_theoretical_E(t, tau, N):
    if N < 1: N = 1
    if tau == 0: return np.zeros_like(t)
    with np.errstate(divide='ignore', invalid='ignore'):
        coeff = (N**N) / (tau**N * math.gamma(N))
        term = t**(N-1)
        exp_term = np.exp(-N * t / tau)
        E = coeff * term * exp_term
    E[np.isnan(E)] = 0
    return E

def sample_dataframe(df, num_points=25):
    if len(df) <= num_points: return df
    indices = np.linspace(0, len(df) - 1, num_points, dtype=int)
    indices = sorted(list(set(indices)))
    return df.iloc[indices].copy()

def process_uploaded_file(uploaded_file, col_target, label):
    try:
        try:
            df = pd.read_csv(uploaded_file, delimiter=';', encoding='utf-8')
        except:
            uploaded_file.seek(0)
            df = pd.read_csv(uploaded_file, delimiter=';', encoding='gbk')
        if len(df.columns) < 2:
            uploaded_file.seek(0)
            df = pd.read_csv(uploaded_file, delimiter=',')
    except Exception as e:
        return None, None, None, f"è¯»å–å¤±è´¥: {e}"

    time_col = df.columns[0]
    try:
        df['Time_Obj'] = pd.to_datetime(df[time_col])
    except:
        df['Time_Obj'] = pd.to_datetime(df[time_col], dayfirst=True, errors='coerce')

    start_t = df['Time_Obj'].iloc[0]
    t_arr = (df['Time_Obj'] - start_t).dt.total_seconds().values
    
    idx_map = {'1å·é‡œ': 1, '2å·é‡œ': 2, '3å·é‡œ': 3, '4å·é‡œ': 4}
    target_idx = -1
    
    if col_target in df.columns:
        raw_C = df[col_target].values
    else:
        for k, v in idx_map.items():
            if k in label:
                target_idx = v
                break
        if target_idx != -1 and target_idx < len(df.columns):
            raw_C = df.iloc[:, target_idx].values
        else:
            return None, None, None, f"æ‰¾ä¸åˆ°åˆ—: {col_target}"

    baseline = raw_C[0]
    net_C = np.maximum(raw_C - baseline, 0)
    area = trapezoid(net_C, t_arr)
    moment_1 = trapezoid(t_arr * net_C, t_arr)
    t_mean = moment_1 / area if area != 0 else 0
    moment_2 = trapezoid(t_arr**2 * net_C, t_arr)
    variance = (moment_2 / area) - t_mean**2 if area != 0 else 0
    N_model = (t_mean**2) / variance if variance != 0 else 0
    E_t = net_C / area if area != 0 else np.zeros_like(net_C)
    full_df = pd.DataFrame({'åŸå§‹æ—¶é—´': df[time_col], 'æ—¶é—´ (s)': t_arr, 'ç”µå¯¼ç‡åŸå§‹å€¼': raw_C, 'ç”µå¯¼ç‡(å‡€)': net_C, 'C*t': net_C * t_arr, 'C*t^2': net_C * (t_arr**2)})
    sampled = sample_dataframe(full_df, 25)
    stats = {'sum_C': area, 'sum_Ct': moment_1, 'sum_Ct2': moment_2, 't_mean': t_mean, 'variance': variance, 'N_model': N_model}
    return sampled, t_arr, E_t, stats

# --- ç•Œé¢éƒ¨åˆ† ---
st.title("âš—ï¸ å¤šé‡œä¸²è”æ•°æ®å¤„ç† (äº¤äº’å›¾è¡¨ç‰ˆ)")
st.caption("ä½¿ç”¨ Plotly å¼•æ“ï¼šæ— éœ€ä¸‹è½½å­—ä½“ï¼ŒåŸç”Ÿæ”¯æŒä¸­æ–‡ï¼Œæ”¯æŒç¼©æ”¾/æ‚¬åœæŸ¥çœ‹æ•°æ®")

with st.sidebar:
    st.header("âš™ï¸ å‚æ•°è®¾ç½®")
    vol_input = st.number_input("ä½“ç§¯ V (mL)", value=1040.0)
    flow_input = st.number_input("æµé‡ Q (mL/min)", value=225.0)
    if flow_input != 0:
        theo_tau = (vol_input / flow_input) * 60
    else:
        theo_tau = 0
    st.info(f"Ï„ = {theo_tau:.2f} s")
    st.divider()
    st.header("ğŸ“‚ æ•°æ®ä¸Šä¼ ")
    file_600 = st.file_uploader("600 rpm (å¿…å¡«)", type=['csv'])
    file_300 = st.file_uploader("300 rpm (å¯é€‰)", type=['csv'])
    file_0 = st.file_uploader("0 rpm (å¯é€‰)", type=['csv'])
    process_btn = st.button("ğŸš€ å¼€å§‹å¤„ç†", type="primary")

if process_btn:
    if not file_600:
        st.error("è¯·å…ˆä¸Šä¼  600 rpm æ•°æ®")
    else:
        output = io.BytesIO()
        writer = pd.ExcelWriter(output, engine='xlsxwriter')
        results_cache = {}
        
        tasks = [
            (file_600, '1#é‡œç”µå¯¼ç‡å€¼', 1, '1å·é‡œ (600 rpm)', '600rpm_1'),
            (file_600, '2#é‡œç”µå¯¼ç‡å€¼', 2, '2å·é‡œ (600 rpm)', '600rpm_2'),
            (file_600, '3#é‡œç”µå¯¼ç‡å€¼', 3, '3å·é‡œ (600 rpm)', '600rpm_3'),
            (file_600, '4#é‡œç”µå¯¼ç‡å€¼', 4, '4å·é‡œ (600 rpm)', '600rpm_4'),
            (file_300, '1#é‡œç”µå¯¼ç‡å€¼', 1, '1å·é‡œ (300 rpm)', '300rpm_1'),
            (file_0,   '1#é‡œç”µå¯¼ç‡å€¼', 1, '1å·é‡œ (0 rpm)',   '0rpm_1')
        ]
        
        for i, (f_obj, col, theo_N, label, sheet) in enumerate(tasks):
            if f_obj is None: continue
            f_obj.seek(0)
            sampled, t_full, E_full, stats = process_uploaded_file(f_obj, col, label)
            if sampled is None:
                st.warning(f"{label} å¤±è´¥: {stats}")
                continue
            
            results_cache[label] = {'t': t_full, 'E': E_full, 'stats': stats}
            
            # Excel å¯¼å‡º
            summary = pd.DataFrame([['N_model', f"{stats['N_model']:.2f}"], ['Variance', f"{stats['variance']:.2f}"]])
            sampled.to_excel(writer, sheet_name=sheet, index=False)
            summary.to_excel(writer, sheet_name=sheet, startcol=6, index=False)

        writer.close()
        st.success("âœ… å¤„ç†å®Œæˆ")
        st.download_button("ğŸ“¥ ä¸‹è½½ Excel æŠ¥è¡¨", data=output.getvalue(), file_name="result.xlsx")

        st.subheader("ğŸ“Š äº¤äº’å¼ç»“æœé¢„è§ˆ")
        tab1, tab2 = st.tabs(["âš¡ è½¬é€Ÿå¯¹æ¯” (å›¾5)", "ğŸ“ˆ è¯¦ç»†æ¨¡å‹æ‹Ÿåˆ"])
        
        # --- âœ… Plotly ç»˜å›¾é€»è¾‘ ---
        
# --- å®šä¹‰ä¸€ä¸ªé€šç”¨çš„ä¸‹è½½é…ç½® (å…³é”®ä¿®æ”¹) ---
        # scale=3 è¡¨ç¤ºä¸‹è½½ 3 å€é«˜æ¸…å›¾ï¼Œé€‚åˆæ‰“å°å’Œ Word æŠ¥å‘Š
        dl_config = {
            'toImageButtonOptions': {
                'format': 'png',        # ä¸‹è½½æ ¼å¼: png, svg, jpeg, webp
                'filename': 'å®éªŒå›¾è¡¨', # ä¸‹è½½çš„æ–‡ä»¶å
                'height': 600,
                'width': 800,
                'scale': 3              # ğŸ” å…³é”®ï¼3å€æ¸…æ™°åº¦ï¼Œå‘Šåˆ«æ¨¡ç³Š
            },
            'displayModeBar': True,     # å¼ºåˆ¶æ˜¾ç¤ºå·¥å…·æ 
            'displaylogo': False,       # éšè— Plotly çš„ logoï¼Œæ›´å¹²å‡€
            # åªä¿ç•™ä¸‹è½½ã€ç¼©æ”¾ã€å¹³ç§»ç­‰æœ‰ç”¨æŒ‰é’®
            'modeBarButtonsToRemove': ['lasso2d', 'select2d'] 
        }

        with tab1:
            fig = go.Figure()
            colors = {'600': '#1f77b4', '300': '#ff7f0e', '0': '#d62728'}
            max_t = 0
            
            for rpm in ['600', '300', '0']:
                key = f'1å·é‡œ ({rpm} rpm)'
                if key in results_cache:
                    d = results_cache[key]
                    fig.add_trace(go.Scatter(x=d['t'], y=d['E'], mode='lines', 
                                           name=f'{rpm} rpm å®æµ‹', line=dict(color=colors[rpm], width=2)))
                    max_t = max(max_t, d['t'].max())
            
            if max_t > 0:
                t_ref = np.linspace(0, max_t, 500)
                E_ref = get_theoretical_E(t_ref, theo_tau, 1)
                fig.add_trace(go.Scatter(x=t_ref, y=E_ref, mode='lines', 
                                       name='ç†è®ºå…¨æ··æµ (N=1)', line=dict(color='black', dash='dash', width=1.5)))

            fig.update_layout(
                title="<b>1å·é‡œä¸åŒè½¬é€Ÿä¸‹ E(t) æ›²çº¿å¯¹æ¯”</b>", # åŠ ç²—æ ‡é¢˜
                xaxis_title="<b>æ—¶é—´ t (s)</b>",
                yaxis_title="<b>E(t) åˆ†å¸ƒ</b>",
                hovermode="x unified",
                template="simple_white", # ä½¿ç”¨æ›´é€‚åˆæ‰“å°çš„ç™½åº•é»‘çº¿æ¨¡æ¿
                legend=dict(yanchor="top", y=0.99, xanchor="right", x=0.99, bgcolor="rgba(255,255,255,0.8)")
            )
            # âœ… åº”ç”¨ä¸‹è½½é…ç½®
            st.plotly_chart(fig, use_container_width=True, config=dl_config)
            
        with tab2:
            st.markdown("##### ğŸ” å„çº§é‡œå®æµ‹æ•°æ®ä¸ç†è®ºæ¨¡å‹å¯¹æ¯”")
            col1, col2 = st.columns(2)
            cols = [col1, col2, col1, col2]
            targets = [('1å·é‡œ (600 rpm)', 1), ('2å·é‡œ (600 rpm)', 2),
                       ('3å·é‡œ (600 rpm)', 3), ('4å·é‡œ (600 rpm)', 4)]
            
            for i, (key, theo_N) in enumerate(targets):
                if key in results_cache:
                    with cols[i]:
                        d = results_cache[key]
                        fig = go.Figure()
                        
                        fig.add_trace(go.Scatter(x=d['t'], y=d['E'], mode='lines', name='å®æµ‹å€¼', line=dict(width=2)))
                        
                        t_ref = np.linspace(0, d['t'].max(), 500)
                        E_theo = get_theoretical_E(t_ref, d['stats']['t_mean'], theo_N)
                        fig.add_trace(go.Scatter(x=t_ref, y=E_theo, mode='lines', 
                                               name=f'ç†è®ºN={theo_N}', line=dict(dash='dash', color='black', width=1.5)))
                        
                        fig.update_layout(
                            title=f"<b>{key}</b> (N={d['stats']['N_model']:.2f})",
                            xaxis_title="æ—¶é—´ (s)",
                            yaxis_title="E(t)",
                            margin=dict(l=40, r=20, t=40, b=40),
                            height=350,
                            template="simple_white",
                            legend=dict(x=0.65, y=0.95, bgcolor="rgba(255,255,255,0.5)")
                        )
                        # âœ… åº”ç”¨ä¸‹è½½é…ç½® (æ¯ä¸ªå°å›¾éƒ½æœ‰ä¸‹è½½æŒ‰é’®)
                        st.plotly_chart(fig, use_container_width=True, config=dl_config)
`
        },
      }, document.getElementById("root")).then(() => {
        document.getElementById("loader").style.display = "none";
      });
    </script>
  </body>
</html>